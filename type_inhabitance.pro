/* Намиране на обитател на тип, ако такъв съществува */

:- op(150, xfx, ⊢).
:- op(150, fx, ⊢).
:- op(145, xfx, ≡).
:- op(140, yfx, $$).
:- op(130, xfx, :).
:- op(120, xfy, =>).
:- op(100, yfx, $).
:- op(100, xfx, @).
:- set_prolog_flag(occurs_check, true).

/*
V @ Γ ⊢ Function : F $$ TypedTerms ≡ Result : R.
↔
В контекст Γ със стек на историята V,
  и за дадена функция Function, която е от тип F,
  можем да намерим подходящи аргументи с типове TypedTerms,
  които, приложени над Function, да връщат резултат Result от даден тип R.
*/

_ @ _  ⊢ Term : T      $$ []                     ≡ Term : T.	/* Функция, приложена над 0 аргумента е самата тя */
V @ Γ  ⊢    M : R => S $$ [ N : R | TypedTerms ] ≡ Term : T	/* Ако термът M е от функционален тип R => S, то можем да го */
								/* приложим над аргумент N от тип R и други аргументи с типове TypedTerms */
								/* и така да получим Term от тип T */ 
	:-
	       V @ Γ ⊢ (M $ N) : S $$ TypedTerms ≡ Term : T,   /* същият, който би се получил, ако бяхме приложили TypedTerms */
								/* дирекнто над апликацията M $ N от тип S */
	       V @ Γ ⊢       N : R.				/* стига да можем в Γ да намерим N от тип R */


/*
V @ Γ ⊢ Term : T
↔
В контекст Γ със стек на историята V можем да намерим Term от тип T
*/
V @ _ ⊢      _ : T      :- member(T, V), !, fail.		/* Ако вече в историята V вече сме търсили терм за типа T, */
								/* прекратяваме търсенето, за да избегнем зацикляне */

V @ Γ ⊢ λ(X,M) : S => T :- V @ [ X : S | Γ ] ⊢ M : T.		/* Ако имаме функционален тип S => T, то търсим терм от вида λ-абстракция */
								/* с тяло M от тип T, като добавяме променлива X от тип S в контекста */

V @ Γ ⊢    App : S      :- 
			   member(X : T, Γ),			/* За произволен тип S пробваме да генерираме апликация, */
								/* която се получава като си изберем някоя променлива X от тип T в контекста Γ, */
			   [S | V] @ Γ ⊢ X : T $$ _ ≡ App : S.  /* и я приложим над аргументи от подходящи типове, генерирани в контекст Γ */
								/* така че получената апликация да е от тип S */
								

⊢ M : T  :- [] @ [] ⊢ M : T.					/* M е обитател на T, ако можем да намерим M от тип T в празен контекст и без история */

/*
?- ⊢ M : α => α.
M = λ(_G17, _G17) 

?- ⊢ M : α => β => α.
M = λ(_G249, λ(_G264, _G249)) 

?- ⊢ M : (α => β) => α => β.
M = λ(_G23, λ(_G38, _G23$_G38)) 

?- ⊢ M : α => (α => β) => β.
M = λ(_G23, λ(_G38, _G38$_G23)) 

?- ⊢ M : (α => β) => α => (β => α) => β.
M = λ(_G29, λ(_G44, λ(_G59, _G29$_G44))) 

?- ⊢ M : (α => β) => α.
false.

?- ⊢ M : (α => β => γ) => (α => β) => α => γ.
M = λ(_G32, λ(_G47, λ(_G62, _G32$_G62$ (_G47$_G62)))) 

*/