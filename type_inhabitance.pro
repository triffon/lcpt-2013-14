/* Намиране на обитател на тип, ако има такъв */

:- op(150, xfx, ⊢).
:- op(150, fx, ⊢).
:- op(145, xfx, ≡).
:- op(140, xfx, :).
:- op(140, xfx, ::).
:- op(130, xfy, ==>).
:- op(120, xfy, =>).
:- op(100, yfx, $$).
:- op(100, yfx, $).
:- op(100, xfx, @).
:- set_prolog_flag(occurs_check, true).

/*
  Types ==> R ≡ T
↔
Типът T може да се представи като функционален тип с няколко аргумента от типове Types и резултат R
*/

          [] ==> T ≡ T.				/* ако няма аргументи, функцията е константа */
[ S | Types] ==> R ≡ (S => T) :- Types ==> R ≡ T.	/* Типът S => T може да се представи като функционален тип */
							/* с първи аргумент от тип S и останали аргументи от типове Types и резултат R, */
							/* T да може да се представи като функционален тип с аргументи от типове Types и резултат R */

/*
  M $$ Terms ≡ N
↔
След прилагане на функцията M над списък от аргументи Terms се получава термът N
*/

           M $$ [] ≡ M.				/* ако няма аргументи, термът остава същият */
M $$ [ N | Terms ] ≡ T :- (M $ N) $$ Terms ≡ T.	/* ако прилагаме M над първи аргумент N и останалите аргументи Terms, ще получим същия терм T, */
							/* който ще получим след прилагане на аргументите Terms директно над апликацията M $ N */


/*
  V @ Γ ⊢ Terms :: Types
↔
В контекст Γ със стек на историята V можем да получим термове Terms от съответните типове Types
*/

_ @ _ ⊢ [] :: [].					/* ако нямаме типове, няма и термове */
V @ Γ ⊢ [ Term | Terms ] :: [ T | Types ] :-		/* да вземем първия тип T */
			V @ Γ ⊢ Term : T,		/* да намерим терм Term за него */
			V @ Γ ⊢ Terms :: Types.	/* след което да намерим термове и за останалите типове */

/*
V @ Γ ⊢ Term : T
↔
В контекст Γ със стек на историята V можем да намерим Term от тип T
*/
  
V @ _ ⊢      _ : T      :- member(T, V), !, fail.               /* Ако вече в историята V вече сме търсили терм за типа T, */
                                                                /* прекратяваме търсенето, за да избегнем зацикляне */

V @ Γ ⊢ λ(X,M) : S => T :- V @ [ X : S | Γ ] ⊢ M : T.           /* Ако имаме функционален тип S => T, то търсим терм от вида λ-абстракция */
                                                                /* с тяло M от тип T, като добавяме променлива X от тип S в контекста */

V @ Γ ⊢ App : S         :-                 			/* За произволен тип S пробваме да генерираме апликация, */
                           member(X : T, Γ),                    /* която се получава като си изберем някоя променлива X от тип T в контекста Γ, */
			   Types ==> S ≡ T,			/* такава, че T може да се представи като функционален тип с аргументи от типове Types и резултат S */
			   [S | V] @ Γ ⊢ Terms :: Types,	/* така че в Γ можем да намерим съответни термове Terms за типовете на аргументите Types */
			   X $$ Terms ≡ App.			/* тогава апликацията от тип S се получава, като приложим термовете Terms над променливата X */

⊢ M : T  :- [] @ [] ⊢ M : T.                                    /* M е обитател на T, ако можем да намерим M от тип T в празен контекст и без история */

/*
?- ⊢ M : α => α.
M = λ(_G17, _G17) 

?- ⊢ M : α => β => α.
M = λ(_G249, λ(_G264, _G249)) 

?- ⊢ M : (α => β) => α => β.
M = λ(_G23, λ(_G38, _G23$_G38)) 

?- ⊢ M : α => (α => β) => β.
M = λ(_G23, λ(_G38, _G38$_G23)) 

?- ⊢ M : (α => β) => α => (β => α) => β.
M = λ(_G29, λ(_G44, λ(_G59, _G29$_G44))) 

?- ⊢ M : (α => β) => α.
false.

?- ⊢ M : (α => β => γ) => (α => β) => α => γ.
M = λ(_G32, λ(_G47, λ(_G62, _G32$_G62$ (_G47$_G62)))) 

*/
